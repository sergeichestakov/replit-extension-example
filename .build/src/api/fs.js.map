{
  "version": 3,
  "sources": ["../../../src/api/fs.ts"],
  "sourcesContent": ["import { extensionPort, proxy } from \"src/util/comlink\";\nimport { WatchFileWatchers, WatchTextFileWatchers } from \"src/types\";\n\n/**\n * Reads the file specified at `path` and returns an object containing the contents, or an object containing an error if there was one\n */\nexport async function readFile(path: string) {\n  return extensionPort.readFile(path);\n}\n\n/**\n * Writes the file specified at `path` with the contents `content`\n */\nexport async function writeFile(path: string, content: string | Blob) {\n  return extensionPort.writeFile(path, content);\n}\n\n/**\n * Reads the directory specified at `path` and returns an object containing the contents, or an object containing an error if there was one\n */\nexport async function readDir(path: string) {\n  return extensionPort.readDir(path);\n}\n\n/**\n * Creates a directory at the specified path\n */\nexport async function createDir(path: string) {\n  return extensionPort.createDir(path);\n}\n\n/**\n * Deletes the file at the specified path\n */\nexport async function deleteFile(path: string) {\n  return extensionPort.deleteFile(path);\n}\n\n/**\n * Deletes the directory at the specified path\n */\nexport async function deleteDir(path: string) {\n  return extensionPort.deleteDir(path);\n}\n\n/**\n * Moves the file or directory at `from` to `to`\n */\nexport async function move(path: string, to: string) {\n  return extensionPort.move(path, to);\n}\n\n/** \n * Copies the file at `from` to `to`\n */\nexport async function copyFile(path: string, to: string) {\n  return extensionPort.copyFile(path, to);\n}\n\n/**\n * Watches the file at `path` for changes with the provided `watchers`. Returns a dispose method which cleans up the watchers\n */\nexport async function watchFile(path: string, watchers: WatchFileWatchers) {\n  // Note: comlink does not let us test for functions being present, so we provide default functions for all callbacks in case the user does not pass those, to keep the API flexible\n  return extensionPort.watchFile(path, proxy({\n    onChange: () => { },\n    onMoveOrDelete: () => { },\n    onError: () => { },\n    ...watchers\n  }));\n}\n\n/**\n * Watches a text file at `path` for changes with the provided `watchers`. Returns a dispose method which cleans up the watchers.\n *  \n * Use this for watching text files, and receive changes as versioned operational transform (OT) operations annotated with their source.\n */\nexport async function watchTextFile(path: string, watchers: WatchTextFileWatchers) {\n  // Note: comlink does not let us test for functions being present, so we provide default functions for all callbacks in case the user does not pass those, to keep the API flexible\n  return extensionPort.watchTextFile(path, proxy({\n    onReady: () => { },\n    onChange: () => { },\n    onMoveOrDelete: () => { },\n    onError: () => { },\n    ...watchers\n  }));\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAAqC;AAMrC,wBAA+B,MAAc;AAC3C,SAAO,6BAAc,SAAS;AAAA;AAMhC,yBAAgC,MAAc,SAAwB;AACpE,SAAO,6BAAc,UAAU,MAAM;AAAA;AAMvC,uBAA8B,MAAc;AAC1C,SAAO,6BAAc,QAAQ;AAAA;AAM/B,yBAAgC,MAAc;AAC5C,SAAO,6BAAc,UAAU;AAAA;AAMjC,0BAAiC,MAAc;AAC7C,SAAO,6BAAc,WAAW;AAAA;AAMlC,yBAAgC,MAAc;AAC5C,SAAO,6BAAc,UAAU;AAAA;AAMjC,oBAA2B,MAAc,IAAY;AACnD,SAAO,6BAAc,KAAK,MAAM;AAAA;AAMlC,wBAA+B,MAAc,IAAY;AACvD,SAAO,6BAAc,SAAS,MAAM;AAAA;AAMtC,yBAAgC,MAAc,UAA6B;AAEzE,SAAO,6BAAc,UAAU,MAAM,0BAAM;AAAA,IACzC,UAAU,MAAM;AAAA;AAAA,IAChB,gBAAgB,MAAM;AAAA;AAAA,IACtB,SAAS,MAAM;AAAA;AAAA,KACZ;AAAA;AASP,6BAAoC,MAAc,UAAiC;AAEjF,SAAO,6BAAc,cAAc,MAAM,0BAAM;AAAA,IAC7C,SAAS,MAAM;AAAA;AAAA,IACf,UAAU,MAAM;AAAA;AAAA,IAChB,gBAAgB,MAAM;AAAA;AAAA,IACtB,SAAS,MAAM;AAAA;AAAA,KACZ;AAAA;",
  "names": []
}
